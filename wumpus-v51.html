<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
  body {
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
  }
  #root {
    width: 100%;
    height: 100%;
  }
</style>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <title>Hunt the Wumpus</title>
</head>
<body>
    <div id="root"></div>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useMemo } = React;

// Add StartScreen component here
// Update StartScreen component to include Blindfold Mode toggle
const StartScreen = ({ onStart, sounds, initialSoundEnabled, initialHardMode, initialBlindfolded, initialExpressMode }) => {
  const [isSoundEnabled, setIsSoundEnabled] = useState(initialSoundEnabled);
  const [isHardMode, setIsHardMode] = useState(initialHardMode);
  const [isBlindfolded, setIsBlindfolded] = useState(initialBlindfolded);
  const [isExpressMode, setIsExpressMode] = useState(initialExpressMode);

  const VolumeIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
      <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
      <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
    </svg>
  );

  const MuteIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
      <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
      <line x1="23" y1="9" x2="17" y2="15"/>
      <line x1="17" y1="9" x2="23" y2="15"/>
    </svg>
  );

  const handleStart = async () => {
    if (isSoundEnabled) {
      try {
        const startSound = sounds.start;
        await startSound.play().then(() => {
          startSound.pause();
          startSound.currentTime = 0;
        });
      } catch (err) {
        console.log('Sound initialization failed:', err);
      }
    }
    onStart(isSoundEnabled, isHardMode, isBlindfolded, isExpressMode);
  };

  return (
    <div className="fixed inset-0 bg-black flex flex-col items-center justify-center p-4">
      <h1 className="text-6xl md:text-7xl font-bold text-white mb-4 tracking-widest">
        WUMPUS
      </h1>
      
      <p className="text-lg md:text-xl text-gray-300 mb-8">
        The hunt is about to begin...but be careful.
      </p>
      
      <div className="bg-gray-900 rounded-lg p-6 mb-8 w-full max-w-md">
        
        {/* Sound Toggle */}
        <div className="flex items-center justify-between mb-6 pb-6 border-b border-gray-700">
          <span className="text-white text-lg">Sound</span>
          <button
            onClick={() => setIsSoundEnabled(!isSoundEnabled)}
            className="text-white hover:text-gray-300 transition-colors"
          >
            {isSoundEnabled ? <VolumeIcon /> : <MuteIcon />}
          </button>
        </div>

        {/* Game Modes Section */}
        <div className="space-y-4">
          {/* Hard Mode */}
          <div className="flex items-center justify-between">
            <span className="text-white text-lg">Hard Mode</span>
            <button
              onClick={() => setIsHardMode(!isHardMode)}
              className={`px-4 py-2 rounded ${isHardMode ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300'} hover:opacity-90 transition-colors`}
            >
              {isHardMode ? 'ON' : 'OFF'}
            </button>
          </div>

          {/* Blindfold Mode */}
          <div className="flex items-center justify-between">
            <span className="text-white text-lg">Blindfold Mode</span>
            <button
              onClick={() => setIsBlindfolded(!isBlindfolded)}
              className={`px-4 py-2 rounded ${isBlindfolded ? 'bg-purple-600 text-white' : 'bg-gray-700 text-gray-300'} hover:opacity-90 transition-colors`}
            >
              {isBlindfolded ? 'ON' : 'OFF'}
            </button>
          </div>

          {/* Express Mode */}
          <div className="flex items-center justify-between">
            <span className="text-white text-lg">Express Mode</span>
            <button
              onClick={() => setIsExpressMode(!isExpressMode)}
              className={`px-4 py-2 rounded ${isExpressMode ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300'} hover:opacity-90 transition-colors`}
            >
              {isExpressMode ? 'ON' : 'OFF'}
            </button>
          </div>

          {/* Unlimited Mode - Coming Soon */}
          <div className="flex items-center justify-between opacity-50">
            <span className="text-white text-lg">Unlimited Mode</span>
            <button
              disabled
              className="px-4 py-2 rounded bg-gray-700 text-gray-300 cursor-not-allowed"
            >
              SOON
            </button>
          </div>
        </div>
      </div>
      
      <button
        onClick={handleStart}
        className="bg-white text-black px-12 py-4 rounded-lg text-2xl hover:bg-gray-200 transition-colors transform hover:scale-105"
      >
        START HUNT
      </button>
    </div>
  );
};
const GameBoard = () => {
  const useScreenDimensions = () => {
    const [dimensions, setDimensions] = useState({
      width: window.innerWidth,
      height: window.innerHeight
    });

    useEffect(() => {
      const handleResize = () => {
        setDimensions({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };

      window.addEventListener('resize', handleResize);
      return () => window.removeEventListener('resize', handleResize);
    }, []);

    return dimensions;
  };

  // Constants
  const PATH_WIDTH = 8;
  const MINIMUM_TILE_SIZE = 30;
  const MAXIMUM_TILE_SIZE = 60;
  const SWIPE_THRESHOLD = 10;  // Reduced from 50 to make swipes more sensitive
const TAP_THRESHOLD = 200;   // Increased from 200 to better distinguish taps from swipes
  
 const screen = useScreenDimensions();
 const pitSound = useMemo(() => {
    const audio = new Audio('sound/pitfall.mp3');  // Add your sound file path
    audio.preload = 'auto';
    return audio;
  }, []);
 const moveSound = useMemo(() => {
  const audio = new Audio('sound/movement.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
    const victorySound = useMemo(() => {
  const audio = new Audio('sound/victory.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
const startGameSound = useMemo(() => {
  const audio = new Audio('sound/start.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
const wumpusDeathSound = useMemo(() => {
  const audio = new Audio('sound/wumpus.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
    // Add with your other useMemo declarations:
const arrowFlightSound = useMemo(() => {
  const audio = new Audio('sound/arrow.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
const batSound = useMemo(() => {
  const audio = new Audio('sound/batwing.mp3');
  audio.preload = 'auto';
  return audio;
}, []);
const arrowModeSound = useMemo(() => {
  const audio = new Audio('sound/armed.mp3');
  audio.preload = 'auto';
  return audio;
}, []);

// Calculate optimal grid dimensions and tile size
const calculateGridDimensions = () => {
  const padding = 32; // 2rem (p-4 * 2)
  const availableWidth = Math.min(screen.width - padding, 900); // Cap max width
  const availableHeight = screen.height - padding;
  
  // For vertical screens (height > width), use 6x8 grid
  if (screen.height > screen.width) {
    // Use 6x8 grid
    let tileSize = Math.min(
      availableWidth / 6,
      availableHeight / 8
    );
    
    // Ensure tile size stays within bounds
    tileSize = Math.min(MAXIMUM_TILE_SIZE, Math.max(MINIMUM_TILE_SIZE, tileSize));
    
    return {
      gridWidth: 6,
      gridHeight: 8,
      tileSize: tileSize
    };
  }
  
  // For horizontal screens, use 8x6 grid
  let tileSize = Math.min(
    availableWidth / 8,
    availableHeight / 6
  );
  
  // Ensure tile size stays within bounds
  tileSize = Math.min(MAXIMUM_TILE_SIZE, Math.max(MINIMUM_TILE_SIZE, tileSize));
  
  return {
    gridWidth: 8,
    gridHeight: 6,
    tileSize: tileSize
  };
};
  



const { gridWidth: GRID_WIDTH, gridHeight: GRID_HEIGHT, tileSize: TILE_SIZE } = calculateGridDimensions();
const RADIUS = TILE_SIZE/2 - 1;
const INNER_RADIUS = RADIUS + PATH_WIDTH;

// Tile type definitions
const TILE_TYPES = {
  CIRCLE: 0,
  CURVE_1: 1,
  CURVE_2: 2,
  PIT: 3,
  POINGLY: 4,
  BAT: 5
};
    const findWarningRooms = (tileMap) => {
  const pitWarningRooms = new Set();
  const wumpusWarningRooms = new Set();
  const wumpusSecondaryWarnings = new Set();
  
  // Helper function to trace path to first circle/pit
  const tracePathToCircle = (startX, startY, dx, dy, isPitWarning = false) => {
    let currentX = startX;
    let currentY = startY;
    let comingFrom = '';
    
    while (true) {
      currentX = (currentX + dx + GRID_WIDTH) % GRID_WIDTH;
      currentY = (currentY + dy + GRID_HEIGHT) % GRID_HEIGHT;
      
      if (dx === 1) comingFrom = 'left';
      if (dx === -1) comingFrom = 'right';
      if (dy === 1) comingFrom = 'top';
      if (dy === -1) comingFrom = 'bottom';
      
      const currentTile = tileMap[currentY][currentX];
      
      // For pit warnings, Poingly rooms are valid targets
      if (isPitWarning && 
          (currentTile === TILE_TYPES.CIRCLE || 
           currentTile === TILE_TYPES.PIT || 
           currentTile === TILE_TYPES.POINGLY ||
           currentTile === TILE_TYPES.BAT)) {
        return { x: currentX, y: currentY };
      }
      
      // For Wumpus warnings, only circles and pits
      if (!isPitWarning && 
          (currentTile === TILE_TYPES.CIRCLE || 
           currentTile === TILE_TYPES.PIT ||
           currentTile === TILE_TYPES.BAT)) {
        return { x: currentX, y: currentY };
      }
      
      // Handle curves
      if (currentTile === TILE_TYPES.CURVE_1) {
        if (comingFrom === 'bottom') { dx = -1; dy = 0; }
        else if (comingFrom === 'left') { dx = 0; dy = 1; }
        else if (comingFrom === 'top') { dx = 1; dy = 0; }
        else if (comingFrom === 'right') { dx = 0; dy = -1; }
      }
      else if (currentTile === TILE_TYPES.CURVE_2) {
        if (comingFrom === 'bottom') { dx = 1; dy = 0; }
        else if (comingFrom === 'right') { dx = 0; dy = 1; }
        else if (comingFrom === 'top') { dx = -1; dy = 0; }
        else if (comingFrom === 'left') { dx = 0; dy = -1; }
      }
    }
  };
  
  // Find all warnings
  for (let y = 0; y < GRID_HEIGHT; y++) {
    for (let x = 0; x < GRID_WIDTH; x++) {
      const tile = tileMap[y][x];
      
      if (tile === TILE_TYPES.PIT) {
        // Check all four directions from the pit, with isPitWarning = true
        [[-1,0], [1,0], [0,-1], [0,1]].forEach(([dx, dy]) => {
          const warning = tracePathToCircle(x, y, dx, dy, true);
          if (warning) {
            pitWarningRooms.add(`${warning.x},${warning.y}`);
          }
        });
      }
      else if (tile === TILE_TYPES.POINGLY) {
        // First find primary warnings (one move away)
        [[-1,0], [1,0], [0,-1], [0,1]].forEach(([dx, dy]) => {
          const warning = tracePathToCircle(x, y, dx, dy);
          if (warning) {
            const key = `${warning.x},${warning.y}`;
            wumpusWarningRooms.add(key);
            
            // From each primary warning, trace one more step
            [[-1,0], [1,0], [0,-1], [0,1]].forEach(([sdx, sdy]) => {
              const secondaryWarning = tracePathToCircle(warning.x, warning.y, sdx, sdy);
              if (secondaryWarning) {
                const secondaryKey = `${secondaryWarning.x},${secondaryWarning.y}`;
                // Don't add if it's the Wumpus tile or a primary warning
                if (secondaryKey !== `${x},${y}` && !wumpusWarningRooms.has(secondaryKey)) {
                  wumpusSecondaryWarnings.add(secondaryKey);
                }
              }
            });
          }
        });
      }
    }
  }
  
  return {
    pitWarnings: pitWarningRooms,
    wumpusWarnings: wumpusWarningRooms,
    wumpusSecondaryWarnings: wumpusSecondaryWarnings
  };
};
// Generate random tile map
const generateNewMap = (isHardMode = false) => {
  const map = new Array(GRID_HEIGHT).fill(null)
    .map(() => new Array(GRID_WIDTH).fill(TILE_TYPES.CIRCLE));
  
  // Place curved tiles randomly (about 25% of tiles)
  const totalTiles = GRID_WIDTH * GRID_HEIGHT;
  const curvedTileRatio = isHardMode ? 0.65 : 0.25; // 65% curves in hard mode vs 25% in normal
  const numCurved = Math.floor(totalTiles * curvedTileRatio);
  let placed = 0;
  
  while (placed < numCurved) {
    const x = Math.floor(Math.random() * GRID_WIDTH);
    const y = Math.floor(Math.random() * GRID_HEIGHT);
    if (map[y][x] === TILE_TYPES.CIRCLE) {
      map[y][x] = Math.random() < 0.5 ? TILE_TYPES.CURVE_1 : TILE_TYPES.CURVE_2;
      placed++;
    }
  }

  // Place pit rooms (2 in normal mode, 3 in hard mode)
  const numPits = isHardMode ? 2 : 2;
  for (let i = 0; i < numPits; i++) {
    let x, y;
    do {
      x = Math.floor(Math.random() * GRID_WIDTH);
      y = Math.floor(Math.random() * GRID_HEIGHT);
    } while (map[y][x] !== TILE_TYPES.CIRCLE);
    map[y][x] = TILE_TYPES.PIT;
  }

  // Place bat rooms (2 in normal mode, 3 in hard mode)
  const numBats = isHardMode ? 2 : 2;
  for (let i = 0; i < numBats; i++) {
    let x, y;
    do {
      x = Math.floor(Math.random() * GRID_WIDTH);
      y = Math.floor(Math.random() * GRID_HEIGHT);
    } while (map[y][x] !== TILE_TYPES.CIRCLE);
    map[y][x] = TILE_TYPES.BAT;
  }
    
  // Place wumpus randomly (1 room)
  let wx, wy;
  do {
    wx = Math.floor(Math.random() * GRID_WIDTH);
    wy = Math.floor(Math.random() * GRID_HEIGHT);
  } while (map[wy][wx] !== TILE_TYPES.CIRCLE);
  map[wy][wx] = TILE_TYPES.POINGLY;
  
  // Find a random empty circle for player start that's not in any warning room
  let sx, sy;
  let maxAttempts = 100;  // Prevent infinite loop
  let attempts = 0;
  const warningRooms = findWarningRooms(map);
  
  do {
    sx = Math.floor(Math.random() * GRID_WIDTH);
    sy = Math.floor(Math.random() * GRID_HEIGHT);
    attempts++;
  } while (
    (map[sy][sx] !== TILE_TYPES.CIRCLE || // Must be a circle room
    warningRooms.pitWarnings.has(`${sx},${sy}`) ||
    warningRooms.wumpusWarnings.has(`${sx},${sy}`) ||
    warningRooms.wumpusSecondaryWarnings.has(`${sx},${sy}`)) &&
    attempts < maxAttempts
  );
  
  // If we couldn't find a perfect start position, just find any circle
  if (attempts >= maxAttempts) {
    do {
      sx = Math.floor(Math.random() * GRID_WIDTH);
      sy = Math.floor(Math.random() * GRID_HEIGHT);
    } while (map[sy][sx] !== TILE_TYPES.CIRCLE);
  }
  
  return { 
    gameMap: map, 
    warningRooms: findWarningRooms(map),
    startPos: { x: sx, y: sy },
    isHardMode: isHardMode
  };
};

const [gameMap, setGameMap] = useState(generateNewMap());
    
    
    
          
// State declarations
const [characterPos, setCharacterPos] = useState(gameMap.startPos);
const [entryDirection, setEntryDirection] = useState(null);
const [gameState, setGameState] = useState('playing');
const [flashCount, setFlashCount] = useState(0);
const [isArrowMode, setIsArrowMode] = useState(false);
const [checkedBatRoom, setCheckedBatRoom] = useState(false);
const [batAnimation, setBatAnimation] = useState(null);  
const [animatingBatRoom, setAnimatingBatRoom] = useState(null);
const [isBeingCarried, setIsBeingCarried] = useState(false);
const [touchStart, setTouchStart] = useState(null);
const [touchStartTime, setTouchStartTime] = useState(null);
const [showArrow, setShowArrow] = useState(false);
const [arrowDirection, setArrowDirection] = useState(null);
const [isGameStarted, setIsGameStarted] = useState(false);  
const [isSoundEnabled, setIsSoundEnabled] = useState(true);
const [isHardMode, setIsHardMode] = useState(false);
const [isBlindfolded, setIsBlindfolded] = useState(false);
const [isExpressMode, setIsExpressMode] = useState(false);
const [showMap, setShowMap] = useState(false);
const [winCount, setWinCount] = useState(0);
const [pitCount, setPitCount] = useState(0);
const [wumpusCount, setWumpusCount] = useState(0);

// Group sounds
const soundEffects = {
  pit: pitSound,
  move: moveSound,
  victory: victorySound,
  start: startGameSound,
  wumpus: wumpusDeathSound,
  arrow: arrowFlightSound,
  bat: batSound,
  arrowMode: arrowModeSound
};

// Add sound helper
const playSound = (sound) => {
  if (isSoundEnabled && sound) {
    sound.play().catch(err => console.log('Audio playback failed:', err));
  }
};


const returnToStart = () => {
  setIsGameStarted(false);
  setGameState('playing');
  setIsArrowMode(false);
  // isHardMode and isBlindfolded states are maintained
};
// Add the new function here
const handlePlayAgain = () => {
  playSound(startGameSound);
  setShowArrow(false);
  setArrowDirection(null);
  const generatedMap = generateNewMap(isHardMode);  // Use stored hard mode setting
  setGameMap(generatedMap);
  setCharacterPos(generatedMap.startPos);
  setEntryDirection(null);
  setGameState('playing');
  setFlashCount(0);
  setIsArrowMode(false);
  setCheckedBatRoom(false);
  setBatAnimation(null);
  setAnimatingBatRoom(null);
  setIsBeingCarried(false);
  // isBlindfolded state is already persisted, no need to set it here
  setVisitedTiles(() => {
    const visited = new Array(GRID_HEIGHT).fill(null)
      .map(() => new Array(GRID_WIDTH).fill(null)
      .map(() => ({
        visited: false,
        topRight: false,
        bottomLeft: false,
        topLeft: false,
        bottomRight: false
      })));
    visited[generatedMap.startPos.y][generatedMap.startPos.x].visited = true;
    return visited;
  });
};
       // Direction mappings
        const keyToDirection = {
          'ArrowUp': 'top',
          'ArrowRight': 'right',
          'ArrowDown': 'bottom',
          'ArrowLeft': 'left'
        };

        const oppositeDirection = {
          'top': 'bottom',
          'right': 'left',
          'bottom': 'top',
          'left': 'right'
        };

          const getSwipeDirection = (touchStart, touchEnd) => {
  if (!touchStart || !touchEnd) return null;
  
  const diffX = touchEnd.clientX - touchStart.clientX;
  const diffY = touchEnd.clientY - touchStart.clientY;
  const absDiffX = Math.abs(diffX);
  const absDiffY = Math.abs(diffY);
  
  // Require minimum swipe distance
  if (Math.max(absDiffX, absDiffY) < SWIPE_THRESHOLD) return null;
  
  // Determine primary direction
  if (absDiffX > absDiffY) {
    return diffX > 0 ? 'ArrowRight' : 'ArrowLeft';
  } else {
    return diffY > 0 ? 'ArrowDown' : 'ArrowUp';
  }
};
        // Helper functions
        const getValidMoves = (pos, tileType, entry) => {
          if (tileType === TILE_TYPES.CIRCLE || tileType === TILE_TYPES.BAT) {
            return ['top', 'right', 'bottom', 'left'];
          }

          if (tileType === TILE_TYPES.CURVE_1) {
            switch(entry) {
              case 'top': return ['right', 'top'];
              case 'right': return ['top', 'right'];
              case 'bottom': return ['left', 'bottom'];
              case 'left': return ['bottom', 'left'];
              default: return ['top', 'right', 'bottom', 'left'];
            }
          }

          if (tileType === TILE_TYPES.CURVE_2) {
            switch(entry) {
              case 'top': return ['left', 'top'];
              case 'right': return ['bottom', 'right'];
              case 'bottom': return ['right', 'bottom'];
              case 'left': return ['top', 'left'];
              default: return ['top', 'right', 'bottom', 'left'];
            }
          }

          return [];
        };
// Add this function before handleMovement in GameBoard:
const findCurveDestination = (startX, startY, direction) => {
  let currentX = startX;
  let currentY = startY;
  let comingFrom = oppositeDirection[direction];
  
  // Follow the curve until we hit a non-curve tile
  while (true) {
    // Move in the current direction
    let newX = currentX;
    let newY = currentY;
    
    switch(direction) {
      case 'top': newY = (newY - 1 + GRID_HEIGHT) % GRID_HEIGHT; break;
      case 'right': newX = (newX + 1) % GRID_WIDTH; break;
      case 'bottom': newY = (newY + 1) % GRID_HEIGHT; break;
      case 'left': newX = (newX - 1 + GRID_WIDTH) % GRID_WIDTH; break;
    }
    
    const nextTile = gameMap.gameMap[newY][newX];
    
    // If we hit a non-curve tile, this is our destination
    if (nextTile !== TILE_TYPES.CURVE_1 && nextTile !== TILE_TYPES.CURVE_2) {
      return { x: newX, y: newY };
    }
    
    // Update position
    currentX = newX;
    currentY = newY;
    
    // Determine new direction based on curve type and entry direction
    if (nextTile === TILE_TYPES.CURVE_1) {
      direction = {
        'bottom': 'left',
        'left': 'bottom',
        'top': 'right',
        'right': 'top'
      }[comingFrom];
    } else { // CURVE_2
      direction = {
        'bottom': 'right',
        'right': 'bottom',
        'top': 'left',
        'left': 'top'
      }[comingFrom];
    }
    
    comingFrom = oppositeDirection[direction];
  }
};
        // Replace the existing traceArrowPath with this version
const traceArrowPath = (startX, startY, direction) => {
  let dx = 0;
  let dy = 0;
  let comingFrom = '';
    
      // Set initial direction
  switch(direction) {
    case 'top': dy = -1; break;
    case 'right': dx = 1; break;
    case 'bottom': dy = 1; break;
    case 'left': dx = -1; break;
  }
  
  let currentX = startX;
  let currentY = startY;
  
  while (true) {
    // Move in the specified direction
    currentX = (currentX + dx + GRID_WIDTH) % GRID_WIDTH;
    currentY = (currentY + dy + GRID_HEIGHT) % GRID_HEIGHT;
    
    // Set which direction we came from
    if (dx === 1) comingFrom = 'left';
    if (dx === -1) comingFrom = 'right';
    if (dy === 1) comingFrom = 'top';
    if (dy === -1) comingFrom = 'bottom';
    
    const currentTile = gameMap.gameMap[currentY][currentX];
    
    // If we hit a circle/pit/poingly tile, this is our target
    if (currentTile === TILE_TYPES.CIRCLE || 
        currentTile === TILE_TYPES.PIT || 
        currentTile === TILE_TYPES.POINGLY) {
      return { x: currentX, y: currentY };
    }
    
    // If we hit a curve, adjust our direction based on the curve type and where we came from
    if (currentTile === TILE_TYPES.CURVE_1) {
      if (comingFrom === 'bottom') { dx = -1; dy = 0; }
      else if (comingFrom === 'left') { dx = 0; dy = 1; }
      else if (comingFrom === 'top') { dx = 1; dy = 0; }
      else if (comingFrom === 'right') { dx = 0; dy = -1; }
    }
    else if (currentTile === TILE_TYPES.CURVE_2) {
      if (comingFrom === 'bottom') { dx = 1; dy = 0; }
      else if (comingFrom === 'right') { dx = 0; dy = 1; }
      else if (comingFrom === 'top') { dx = -1; dy = 0; }
      else if (comingFrom === 'left') { dx = 0; dy = -1; }
    }
  }
};

const findRandomBatLanding = (map) => {
  // 10% chance to land in a dangerous room
  const dangerRoll = Math.random();
  if (dangerRoll < 0.10) {
    // Find all pit and wumpus rooms
    const dangerRooms = [];
    for (let y = 0; y < GRID_HEIGHT; y++) {
      for (let x = 0; x < GRID_WIDTH; x++) {
        if (map[y][x] === TILE_TYPES.PIT || map[y][x] === TILE_TYPES.POINGLY) {
          dangerRooms.push({ x, y });
        }
      }
    }
    // If there are any danger rooms, randomly pick one
    if (dangerRooms.length > 0) {
      return dangerRooms[Math.floor(Math.random() * dangerRooms.length)];
    }
  }
  
  // Otherwise find a safe circle room as before
  let x, y;
  do {
    x = Math.floor(Math.random() * GRID_WIDTH);
    y = Math.floor(Math.random() * GRID_HEIGHT);
  } while (map[y][x] !== TILE_TYPES.CIRCLE);
  return { x, y };
};



// Add bat room component
const BatRoom = ({ x, y, isAnimating }) => {
  const startX = x * TILE_SIZE;
  const startY = y * TILE_SIZE;
  const center = TILE_SIZE/2;
  const BAT_SIZE = TILE_SIZE/2.5;
  const BAT_Y_OFFSET = -TILE_SIZE/4;
  const LIFT_DISTANCE = TILE_SIZE/3; // Reduced from TILE_SIZE/2
  
  return (
    <g transform={`translate(${startX}, ${startY})`}>
      {/* Base circle room */}
      <Circle x={0} y={0} />
      
      {/* Animated bat design */}
      <g transform={`translate(${center - BAT_SIZE/2}, ${center + BAT_Y_OFFSET})`}>
        {isAnimating ? (
          // Animated lifting bat
          <g>
            <animateTransform
              attributeName="transform"
              type="translate"
              from={`0 0`}
              to={`0 ${-LIFT_DISTANCE}`}
              dur="0.5s"
              fill="freeze"
            />
            {/* Left wing */}
            <path
              d={`M 0,0 
                  C ${BAT_SIZE/4},${-BAT_SIZE/2} ${BAT_SIZE/2},${-BAT_SIZE/4} ${BAT_SIZE/2},${BAT_SIZE/4}
                  C ${BAT_SIZE/2},${BAT_SIZE/2} ${BAT_SIZE/4},${BAT_SIZE/4} 0,0`}
              fill="#800000"
            />
            {/* Right wing */}
            <path
              d={`M ${BAT_SIZE},0 
                  C ${BAT_SIZE*3/4},${-BAT_SIZE/2} ${BAT_SIZE/2},${-BAT_SIZE/4} ${BAT_SIZE/2},${BAT_SIZE/4}
                  C ${BAT_SIZE/2},${BAT_SIZE/2} ${BAT_SIZE*3/4},${BAT_SIZE/4} ${BAT_SIZE},0`}
              fill="#800000"
            />
            {/* Body */}
            <ellipse
              cx={BAT_SIZE/2}
              cy={BAT_SIZE/4}
              rx={BAT_SIZE/4}
              ry={BAT_SIZE/3}
              fill="#800000"
            />
            {/* Eyes */}
            <circle cx={BAT_SIZE*3/8} cy={BAT_SIZE/8} r={BAT_SIZE/12} fill="#ff0000" />
            <circle cx={BAT_SIZE*5/8} cy={BAT_SIZE/8} r={BAT_SIZE/12} fill="#ff0000" />
          </g>
        ) : (
          // Normal bat
          <g>
            {/* Left wing */}
            <path
              d={`M 0,0 
                  C ${BAT_SIZE/4},${-BAT_SIZE/2} ${BAT_SIZE/2},${-BAT_SIZE/4} ${BAT_SIZE/2},${BAT_SIZE/4}
                  C ${BAT_SIZE/2},${BAT_SIZE/2} ${BAT_SIZE/4},${BAT_SIZE/4} 0,0`}
              fill="#666666"
            />
            {/* Right wing */}
            <path
              d={`M ${BAT_SIZE},0 
                  C ${BAT_SIZE*3/4},${-BAT_SIZE/2} ${BAT_SIZE/2},${-BAT_SIZE/4} ${BAT_SIZE/2},${BAT_SIZE/4}
                  C ${BAT_SIZE/2},${BAT_SIZE/2} ${BAT_SIZE*3/4},${BAT_SIZE/4} ${BAT_SIZE},0`}
              fill="#666666"
            />
            {/* Body */}
            <ellipse
              cx={BAT_SIZE/2}
              cy={BAT_SIZE/4}
              rx={BAT_SIZE/4}
              ry={BAT_SIZE/3}
              fill="#666666"
            />
            {/* Eyes */}
            <circle cx={BAT_SIZE*3/8} cy={BAT_SIZE/8} r={BAT_SIZE/12} fill="#ffffff" />
            <circle cx={BAT_SIZE*5/8} cy={BAT_SIZE/8} r={BAT_SIZE/12} fill="#ffffff" />
          </g>
        )}
      </g>
    </g>
  );
};
const GameOverMap = ({ gameMap, onClose }) => {
  return (
    <div className="fixed inset-0 bg-black">
      <div className="w-full h-full p-4 flex flex-col">
        <button 
          onClick={onClose}
          className="self-end text-white hover:text-gray-300 mb-4"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <div className="flex-grow flex items-center justify-center">
          <svg 
            viewBox={`0 0 ${GRID_WIDTH * TILE_SIZE} ${GRID_HEIGHT * TILE_SIZE}`}
            style={{
              width: '100%',
              maxWidth: '900px',
              height: '100%',
              maxHeight: '90vh'
            }}
            preserveAspectRatio="xMidYMid meet"
          >
            <rect 
              x="0" 
              y="0" 
              width={GRID_WIDTH * TILE_SIZE} 
              height={GRID_HEIGHT * TILE_SIZE} 
              fill="none" 
              stroke="rgba(255, 255, 255, 0.2)" 
              strokeWidth="1"
            />
            {gameMap.gameMap.map((row, y) =>
              row.map((tileType, x) => {
                const key = `${x},${y}`;
                return (
                  <g key={key}>
                    {tileType === TILE_TYPES.CIRCLE && <Circle x={x} y={y} />}
                    {tileType === TILE_TYPES.CURVE_1 && <CurvePattern1 x={x} y={y} />}
                    {tileType === TILE_TYPES.CURVE_2 && <CurvePattern2 x={x} y={y} />}
                    {tileType === TILE_TYPES.PIT && <PitRoom x={x} y={y} />}
                    {gameMap.warningRooms.pitWarnings.has(key) && <BreezeWarning x={x} y={y} />}
                    {(gameMap.warningRooms.wumpusWarnings.has(key) ||
                      gameMap.warningRooms.wumpusSecondaryWarnings.has(key)) && 
                      <WumpusWarning x={x} y={y} />}
                    {tileType === TILE_TYPES.POINGLY && <PoinglyRoom x={x} y={y} />}
                    {tileType === TILE_TYPES.BAT && <BatRoom x={x} y={y} isAnimating={false} />}
                  </g>
                );
              })
            )}
          </svg>
        </div>
      </div>
    </div>
  );
};

        // Game components (Circle, CurvePattern1, CurvePattern2, etc.)
        const Circle = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    const center = TILE_SIZE/2;
    
    return (
      <g transform={`translate(${startX}, ${startY})`}>
        {/* Top-right arc */}
        <path
          d={`M ${center + PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 1 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Bottom-right arc */}
        <path
          d={`M ${TILE_SIZE},${center + PATH_WIDTH/2}
              A ${RADIUS} ${RADIUS} 0 0 1 ${center + PATH_WIDTH/2},${TILE_SIZE}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Bottom-left arc */}
        <path
          d={`M ${center - PATH_WIDTH/2},${TILE_SIZE}
              A ${RADIUS} ${RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Top-left arc */}
        <path
          d={`M 0,${center - PATH_WIDTH/2}
              A ${RADIUS} ${RADIUS} 0 0 1 ${center - PATH_WIDTH/2},0`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
      </g>
    );
  };

  const CurvePattern1 = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    const center = TILE_SIZE/2;
    
    return (
      <g transform={`translate(${startX}, ${startY})`}>
        {/* Top-to-right curve */}
        <path
          d={`M ${center - PATH_WIDTH/2},0 
              A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 0 ${TILE_SIZE},${center + PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        <path
          d={`M ${center + PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 0 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />

        {/* 180° rotated curve */}
        <g transform={`rotate(180, ${center}, ${center})`}>
          <path
            d={`M ${center - PATH_WIDTH/2},0 
                A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 0 ${TILE_SIZE},${center + PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
          <path
            d={`M ${center + PATH_WIDTH/2},0 
                A ${RADIUS} ${RADIUS} 0 0 0 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
        </g>
      </g>
    );
  };

  const CurvePattern2 = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    const center = TILE_SIZE/2;
    
    return (
      <g transform={`translate(${startX}, ${startY})`}>
        {/* Top-to-left curve */}
        <path
          d={`M ${center + PATH_WIDTH/2},0 
              A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        <path
          d={`M ${center - PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 1 0,${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />

        {/* 180° rotated curve */}
        <g transform={`rotate(180, ${center}, ${center})`}>
          <path
            d={`M ${center + PATH_WIDTH/2},0 
                A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
          <path
            d={`M ${center - PATH_WIDTH/2},0 
                A ${RADIUS} ${RADIUS} 0 0 1 0,${center - PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
        </g>
      </g>
    );
  };
const PartialCurvePattern1 = ({ x, y, showTopRight, showBottomLeft }) => {
  const startX = x * TILE_SIZE;
  const startY = y * TILE_SIZE;
  const center = TILE_SIZE/2;
  
  return (
    <g transform={`translate(${startX}, ${startY})`}>
      {/* Top-right part */}
      {showTopRight && (
        <path
          d={`M ${center - PATH_WIDTH/2},0 
              A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 0 ${TILE_SIZE},${center + PATH_WIDTH/2}
              M ${center + PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 0 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
      )}

      {/* Bottom-left part */}
      {showBottomLeft && (
        <g transform={`rotate(180, ${center}, ${center})`}>
          <path
            d={`M ${center - PATH_WIDTH/2},0 
                A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 0 ${TILE_SIZE},${center + PATH_WIDTH/2}
                M ${center + PATH_WIDTH/2},0 
                A ${RADIUS} ${RADIUS} 0 0 0 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
        </g>
      )}
    </g>
  );
};

const PartialCurvePattern2 = ({ x, y, showTopLeft, showBottomRight }) => {
  const startX = x * TILE_SIZE;
  const startY = y * TILE_SIZE;
  const center = TILE_SIZE/2;
  
  return (
    <g transform={`translate(${startX}, ${startY})`}>
      {/* Top-left part */}
      {showTopLeft && (
        <path
          d={`M ${center + PATH_WIDTH/2},0 
              A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}
              M ${center - PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 1 0,${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
      )}

      {/* Bottom-right part */}
      {showBottomRight && (
        <g transform={`rotate(180, ${center}, ${center})`}>
          <path
            d={`M ${center + PATH_WIDTH/2},0 
                A ${INNER_RADIUS} ${INNER_RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}
                M ${center - PATH_WIDTH/2},0 
                A ${RADIUS} ${RADIUS} 0 0 1 0,${center - PATH_WIDTH/2}`}
            stroke="#8080ff"
            strokeWidth="2"
            fill="none"
          />
        </g>
      )}
    </g>
  );
};
          
const PitRoom = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    const center = TILE_SIZE/2;
    const PIT_RADIUS = TILE_SIZE/3;  // Scaled to tile size
    
    return (
      <g transform={`translate(${startX}, ${startY})`}>
        {/* Room circle with openings - same as Circle component */}
        {/* Top-right arc */}
        <path
          d={`M ${center + PATH_WIDTH/2},0 
              A ${RADIUS} ${RADIUS} 0 0 1 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Bottom-right arc */}
        <path
          d={`M ${TILE_SIZE},${center + PATH_WIDTH/2}
              A ${RADIUS} ${RADIUS} 0 0 1 ${center + PATH_WIDTH/2},${TILE_SIZE}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Bottom-left arc */}
        <path
          d={`M ${center - PATH_WIDTH/2},${TILE_SIZE}
              A ${RADIUS} ${RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />
        {/* Top-left arc */}
        <path
          d={`M 0,${center - PATH_WIDTH/2}
              A ${RADIUS} ${RADIUS} 0 0 1 ${center - PATH_WIDTH/2},0`}
          stroke="#8080ff"
          strokeWidth="2"
          fill="none"
        />

        {/* Pit */}
        <defs>
          <radialGradient id={`pitGradient-${x}-${y}`} cx="50%" cy="50%" r="50%">
            <stop offset="0%" stopColor="#004400" />
            <stop offset="70%" stopColor="#00ff00" />
            <stop offset="100%" stopColor="#00aa00" />
          </radialGradient>
          <radialGradient id={`pitHighlight-${x}-${y}`} cx="40%" cy="40%" r="60%">
            <stop offset="0%" stopColor="#ffffff" stopOpacity="0.2" />
            <stop offset="100%" stopColor="#ffffff" stopOpacity="0" />
          </radialGradient>
        </defs>
        <circle 
          cx={center} 
          cy={center} 
          r={PIT_RADIUS} 
          fill={`url(#pitGradient-${x}-${y})`}
        />
        <circle 
          cx={center} 
          cy={center} 
          r={PIT_RADIUS} 
          fill={`url(#pitHighlight-${x}-${y})`}
        />
        <circle 
          cx={center} 
          cy={center} 
          r={PIT_RADIUS + 3} 
          stroke="#00ff00" 
          strokeWidth="1" 
          fill="none" 
          opacity="0.5"
        />
      </g>
    );
  };
const PoinglyRoom = ({ x, y }) => {
  const startX = x * TILE_SIZE;
  const startY = y * TILE_SIZE;
  const center = TILE_SIZE/2;
  const MONSTER_SIZE = TILE_SIZE/3;

  return (
    <g transform={`translate(${startX}, ${startY})`}>
      {/* Room circle with openings */}
      <path
        d={`M ${center + PATH_WIDTH/2},0 
            A ${RADIUS} ${RADIUS} 0 0 1 ${TILE_SIZE},${center - PATH_WIDTH/2}`}
        stroke="#8080ff"
        strokeWidth="2"
        fill="none"
      />
      <path
        d={`M ${TILE_SIZE},${center + PATH_WIDTH/2}
            A ${RADIUS} ${RADIUS} 0 0 1 ${center + PATH_WIDTH/2},${TILE_SIZE}`}
        stroke="#8080ff"
        strokeWidth="2"
        fill="none"
      />
      <path
        d={`M ${center - PATH_WIDTH/2},${TILE_SIZE}
            A ${RADIUS} ${RADIUS} 0 0 1 0,${center + PATH_WIDTH/2}`}
        stroke="#8080ff"
        strokeWidth="2"
        fill="none"
      />
      <path
        d={`M 0,${center - PATH_WIDTH/2}
            A ${RADIUS} ${RADIUS} 0 0 1 ${center - PATH_WIDTH/2},0`}
        stroke="#8080ff"
        strokeWidth="2"
        fill="none"
      />

      {/* Poingly monster */}
      <g transform={`translate(${center}, ${center})`}>
        {/* Body */}
        <circle
          r={MONSTER_SIZE}
          fill="#ff0000"
        />
        
        {/* Eyes */}
        <circle
          cx={-MONSTER_SIZE/3}
          cy={-MONSTER_SIZE/4}
          r={MONSTER_SIZE/6}
          fill="white"
        />
        <circle
          cx={MONSTER_SIZE/3}
          cy={-MONSTER_SIZE/4}
          r={MONSTER_SIZE/6}
          fill="white"
        />
        <circle
          cx={-MONSTER_SIZE/3}
          cy={-MONSTER_SIZE/4}
          r={MONSTER_SIZE/12}
          fill="black"
        />
        <circle
          cx={MONSTER_SIZE/3}
          cy={-MONSTER_SIZE/4}
          r={MONSTER_SIZE/12}
          fill="black"
        />

        {/* Teeth */}
        <path
          d={`M ${-MONSTER_SIZE/2} ${MONSTER_SIZE/4} 
              L ${-MONSTER_SIZE/4} ${MONSTER_SIZE/2} 
              L 0 ${MONSTER_SIZE/4} 
              L ${MONSTER_SIZE/4} ${MONSTER_SIZE/2}
              L ${MONSTER_SIZE/2} ${MONSTER_SIZE/4}`}
          stroke="white"
          strokeWidth="2"
          fill="none"
        />
      </g>
    </g>
  );
};
    const BreezeWarning = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    
    // Create varied bubble configurations
    const bubbles = [
        { size: 4, speed: "2.8s", delay: "0s", offset: -12 },
        { size: 2, speed: "3.2s", delay: "0.4s", offset: -8 },
        { size: 3, speed: "2.5s", delay: "1.2s", offset: -4 },
        { size: 5, speed: "3.5s", delay: "0.8s", offset: 0 },
        { size: 2, speed: "2.2s", delay: "1.6s", offset: 4 },
        { size: 4, speed: "3.0s", delay: "2.0s", offset: 8 },
        { size: 3, speed: "2.6s", delay: "1.0s", offset: 12 },
        { size: 2, speed: "2.4s", delay: "0.2s", offset: -6 },
        { size: 4, speed: "3.3s", delay: "1.4s", offset: 6 },
        { size: 3, speed: "2.7s", delay: "1.8s", offset: 10 }
    ];
    
    return (
        <g transform={`translate(${startX}, ${startY})`}>
            <defs>
                <clipPath id={`circleClip-${x}-${y}`}>
                    <circle cx={TILE_SIZE/2} cy={TILE_SIZE/2} r={RADIUS - 2} />
                </clipPath>
            </defs>
            <g clipPath={`url(#circleClip-${x}-${y})`}>
                {bubbles.map((bubble, i) => (
                    <circle key={i} r={bubble.size}>
                        <animateMotion
                            path={`M ${TILE_SIZE/2 + bubble.offset} ${TILE_SIZE} V ${0}`}
                            dur={bubble.speed}
                            begin={bubble.delay}
                            repeatCount="indefinite"
                        />
                        <animate
                            attributeName="opacity"
                            values="0;0.8;0.8;0"
                            dur={bubble.speed}
                            begin={bubble.delay}
                            repeatCount="indefinite"
                        />
                        <animate
                            attributeName="r"
                            values={`${bubble.size};${bubble.size * 1.5};${bubble.size}`}
                            dur={bubble.speed}
                            repeatCount="indefinite"
                        />
                        <animate
                            attributeName="fill"
                            values="#00ff00;#00aa00;#00ff00"
                            dur={bubble.speed}
                            repeatCount="indefinite"
                        />
                    </circle>
                ))}
            </g>
        </g>
    );
};
const WumpusWarning = ({ x, y }) => {
  const startX = x * TILE_SIZE;
  const startY = y * TILE_SIZE;
  const center = TILE_SIZE/2;
  const WARNING_SIZE = TILE_SIZE/4;
  
  return (
    <g transform={`translate(${startX}, ${startY})`}>
      <circle 
        cx={center} 
        cy={center} 
        r={WARNING_SIZE}>
        <animate
          attributeName="fill"
          values="#ff0000;#990000;#ff0000"
          dur="2s"
          repeatCount="indefinite"
        />
        <animate
          attributeName="r"
          values={`${WARNING_SIZE};${WARNING_SIZE * 1.2};${WARNING_SIZE}`}
          dur="2s"
          repeatCount="indefinite"
        />
      </circle>
    </g>
  );
};
const FogTile = ({ x, y }) => {
    const startX = x * TILE_SIZE;
    const startY = y * TILE_SIZE;
    
    return (
      <rect
        x={startX}
        y={startY}
        width={TILE_SIZE}
        height={TILE_SIZE}
        fill="black"
        stroke="#1a1a1a"
        strokeWidth="0"
        pointerEvents="none"
      />
    );
  };
const Character = ({ x, y, tileType, entryDirection, batAnimation, isArrowMode }) => {
  const baseX = x * TILE_SIZE + TILE_SIZE/2;
  const baseY = y * TILE_SIZE + TILE_SIZE/2;
  const curveOffset = TILE_SIZE/6;
  const LIFT_DISTANCE = TILE_SIZE/3;
  const PERSON_SIZE = PATH_WIDTH * 1.5; // Base size for the person

  // Helper function to draw person at given coordinates
   const PersonShape = ({cx, cy, fill = isArrowMode ? "#00ffff" : "#ffff00"}) => (
    <g transform={`translate(${cx}, ${cy})`}>
      {/* Head */}
      <circle 
        cx="0" 
        cy={-PERSON_SIZE/2} 
        r={PERSON_SIZE/4} // Reduced from /3
        fill={fill} 
      />
      {/* Body */}
      <line 
        x1="0" 
        y1={-PERSON_SIZE/3} 
        x2="0" 
        y2={PERSON_SIZE/3} 
        stroke={fill} 
        strokeWidth={PERSON_SIZE/6} // Reduced from /4
      />
      {/* Arms */}
      <line 
        x1={-PERSON_SIZE/2} 
        y1={-PERSON_SIZE/6} 
        x2={PERSON_SIZE/2} 
        y2={-PERSON_SIZE/6} 
        stroke={fill} 
        strokeWidth={PERSON_SIZE/6} // Reduced from /4
      />
      {/* Legs */}
      <line 
        x1="0" 
        y1={PERSON_SIZE/3} 
        x2={-PERSON_SIZE/2} 
        y2={PERSON_SIZE} 
        stroke={fill} 
        strokeWidth={PERSON_SIZE/6} // Reduced from /4
      />
      <line 
        x1="0" 
        y1={PERSON_SIZE/3} 
        x2={PERSON_SIZE/2} 
        y2={PERSON_SIZE} 
        stroke={fill} 
        strokeWidth={PERSON_SIZE/6} // Reduced from /4
      />
    </g>
  );

  if (batAnimation === 'pickup') {
    return (
      <g>
        <PersonShape cx={baseX} cy={baseY}>
          <animate
            attributeName="cy"
            from={baseY}
            to={baseY - LIFT_DISTANCE}
            dur="0.5s"
            fill="freeze"
          />
        </PersonShape>
      </g>
    );
  }

  // For Pattern 1 (top-right/bottom-left curves)
  if (tileType === TILE_TYPES.CURVE_1) {
    switch(entryDirection) {
      case 'bottom':
        return <PersonShape cx={baseX - curveOffset} cy={baseY + curveOffset} />;
      case 'left':
        return <PersonShape cx={baseX - curveOffset} cy={baseY + curveOffset} />;
      case 'top':
        return <PersonShape cx={baseX + curveOffset} cy={baseY - curveOffset} />;
      case 'right':
        return <PersonShape cx={baseX + curveOffset} cy={baseY - curveOffset} />;
      default:
        return <PersonShape cx={baseX} cy={baseY} />;
    }
  }

  // For Pattern 2 (top-left/bottom-right curves)
  if (tileType === TILE_TYPES.CURVE_2) {
    switch(entryDirection) {
      case 'bottom':
        return <PersonShape cx={baseX + curveOffset} cy={baseY + curveOffset} />;
      case 'right':
        return <PersonShape cx={baseX + curveOffset} cy={baseY + curveOffset} />;
      case 'top':
        return <PersonShape cx={baseX - curveOffset} cy={baseY - curveOffset} />;
      case 'left':
        return <PersonShape cx={baseX - curveOffset} cy={baseY - curveOffset} />;
      default:
        return <PersonShape cx={baseX} cy={baseY} />;
    }
  }

  return <PersonShape cx={baseX} cy={baseY} />;
};

// First, add this new Arrow component right after the Character component and before the return statement:

// Replace the existing Arrow component with this debugged version:

const Arrow = ({ viewportWidth, viewportHeight, direction, onComplete }) => {
  const centerX = viewportWidth / 2;
  const centerY = viewportHeight / 2;

  let rotation = direction === 'right' ? 0 :
                 direction === 'left' ? 180 :
                 direction === 'top' ? 270 :
                 90;  // down arrow rotated 90 degrees

  const horizontalDistance = viewportWidth;
  const verticalDistance = viewportHeight;

  let startPos, endPos;
  if (direction === 'right' || direction === 'bottom') {  // Use right arrow pattern for both right and down
    startPos = `translate(${-horizontalDistance/2}px, 0)`;
    endPos = `translate(${horizontalDistance/2}px, 0)`;
  } else if (direction === 'left' || direction === 'top') {  // Use left arrow pattern for both left and up
    startPos = `translate(${-horizontalDistance/2}px, 0)`;
    endPos = `translate(${horizontalDistance/2}px, 0)`;
  }

  return (
    <g>
      <rect 
        x="0"
        y="0"
        width={viewportWidth}
        height={viewportHeight}
        fill="rgba(0,0,0,0.7)"
      />
      <g transform={`translate(${centerX}, ${centerY})`}>
        <g transform={`rotate(${rotation})`}>
          <g style={{
            animation: 'moveArrow 3s linear',
            transform: startPos,
          }} onAnimationEnd={onComplete}>
            <style>
              {`
                @keyframes moveArrow {
                  from { transform: ${startPos}; }
                  to { transform: ${endPos}; }
                }
              `}
            </style>
            <line x1="-20" y1="0" x2="20" y2="0" stroke="#4af" strokeWidth="8" strokeLinecap="round"/>
            <path d="M 20 0 L 5 -10 L 35 0 L 5 10 Z" fill="#4af"/>
            <path d="M -20 0 L -35 -10 L -25 0 L -35 10 Z" fill="#4af"/>
          </g>
        </g>
      </g>
    </g>
  );
};
    
const [visitedTiles, setVisitedTiles] = useState(() => {
  const visited = new Array(GRID_HEIGHT).fill(null)
    .map(() => new Array(GRID_WIDTH).fill(null)
    .map(() => ({
      visited: false,
      topRight: false,    // for CURVE_1
      bottomLeft: false,  // for CURVE_1
      topLeft: false,     // for CURVE_2
      bottomRight: false  // for CURVE_2
    })));
  // Mark starting position as visited
  visited[gameMap.startPos.y][gameMap.startPos.x].visited = true;
  return visited;
});
    
// Add game start handler
  const handleGameStart = (soundEnabled, hardMode, blindfolded, expressMode) => {
  setIsExpressMode(expressMode);
  setIsHardMode(hardMode);
  setIsBlindfolded(blindfolded);
  setIsSoundEnabled(soundEnabled);
  setIsGameStarted(true);
  setGameState('playing');
  setIsArrowMode(false);
  const generatedMap = generateNewMap(hardMode);
  setGameMap(generatedMap);
  setCharacterPos(generatedMap.startPos);
  setEntryDirection(null);
  setVisitedTiles(() => {
    const visited = new Array(GRID_HEIGHT).fill(null)
      .map(() => new Array(GRID_WIDTH).fill(null)
      .map(() => ({
        visited: false,
        topRight: false,
        bottomLeft: false,
        topLeft: false,
        bottomRight: false
      })));
    visited[generatedMap.startPos.y][generatedMap.startPos.x].visited = true;
    return visited;
  });
  if (soundEnabled) {
    startGameSound.play().catch(err => console.log('Audio playback failed:', err));
  }
};
    
const handleMovement = (direction, newPos) => {
  if (isBeingCarried) return;

  if (isExpressMode) {
    const nextTile = gameMap.gameMap[newPos.y][newPos.x];
    if (nextTile === TILE_TYPES.CURVE_1 || nextTile === TILE_TYPES.CURVE_2) {
      // Find where we'll end up after following the curves
      const destination = findCurveDestination(characterPos.x, characterPos.y, direction);
      newPos = destination;
    }
  }

  playSound(moveSound);
  const newTileType = gameMap.gameMap[newPos.y][newPos.x];

  // Mark new position as visited
  const newVisited = visitedTiles.map(row => row.map(cell => ({...cell})));
  const tileType = gameMap.gameMap[newPos.y][newPos.x];

  if (tileType === TILE_TYPES.CURVE_1) {
    switch(direction) {
      case 'top':
      case 'right':
        newVisited[newPos.y][newPos.x].bottomLeft = true;
        if (visitedTiles[newPos.y][newPos.x].topRight) {
          newVisited[newPos.y][newPos.x].visited = true;
        }
        break;
      case 'bottom':
      case 'left':
        newVisited[newPos.y][newPos.x].topRight = true;
        if (visitedTiles[newPos.y][newPos.x].bottomLeft) {
          newVisited[newPos.y][newPos.x].visited = true;
        }
        break;
    }
  } else if (tileType === TILE_TYPES.CURVE_2) {
    switch(direction) {
      case 'top':
      case 'left':
        newVisited[newPos.y][newPos.x].bottomRight = true;
        if (visitedTiles[newPos.y][newPos.x].topLeft) {
          newVisited[newPos.y][newPos.x].visited = true;
        }
        break;
      case 'bottom':
      case 'right':
        newVisited[newPos.y][newPos.x].topLeft = true;
        if (visitedTiles[newPos.y][newPos.x].bottomRight) {
          newVisited[newPos.y][newPos.x].visited = true;
        }
        break;
    }
  } else {
    newVisited[newPos.y][newPos.x].visited = true;
  }

  setVisitedTiles(newVisited);

  if (newTileType === TILE_TYPES.BAT) {
    if (!checkedBatRoom) {
      setCheckedBatRoom(true);
      const roll = Math.random();
      if (roll < 0.3) {  // 30% chance of bats picking you up
  setIsBeingCarried(true);
  playSound(batSound);
  setAnimatingBatRoom({x: newPos.x, y: newPos.y});
  setBatAnimation('pickup');
    // Add this line
        
        setTimeout(() => {
  const randomPos = findRandomBatLanding(gameMap.gameMap);
  // Keep track of the bat's original position
  const batX = newPos.x;
  const batY = newPos.y;
  
  // Update the map
  const newMap = [...gameMap.gameMap.map(row => [...row])];
  newMap[batY][batX] = TILE_TYPES.CIRCLE;
  gameMap.gameMap = newMap;
  
  // Update visited tiles - keep bat room visible and add new landing spot
  const finalVisited = visitedTiles.map(row => row.map(cell => ({...cell})));
  finalVisited[batY][batX].visited = true;  // Ensure bat room stays visible
  finalVisited[randomPos.y][randomPos.x].visited = true;  // Make new landing room visible
  setVisitedTiles(finalVisited);
  
  setCharacterPos(randomPos);
  setEntryDirection(null);
  setBatAnimation(null);
  setAnimatingBatRoom(null);
  setCheckedBatRoom(false);
  setIsBeingCarried(false);

  // Handle landing in a dangerous room
  const landingTile = gameMap.gameMap[randomPos.y][randomPos.x];
  if (landingTile === TILE_TYPES.PIT) {
    playSound(pitSound);
    setGameState('pit');
    setPitCount(prev => prev + 1);
    setFlashCount(1);
  } else if (landingTile === TILE_TYPES.POINGLY) {
    playSound(wumpusDeathSound);
    setGameState('poingly');
    setWumpusCount(prev => prev + 1);
  }
}, 500);

      }
    }
    setCharacterPos(newPos);
    setEntryDirection(oppositeDirection[direction]);
  } else if (newTileType === TILE_TYPES.PIT) {
    playSound(pitSound);
    setGameState('pit');
    setPitCount(prev => prev + 1); 
    setFlashCount(1);
} else if (newTileType === TILE_TYPES.POINGLY) {
    playSound(wumpusDeathSound); 
    setGameState('poingly');
    setWumpusCount(prev => prev + 1);
  } else {
    setCharacterPos(newPos);
    setEntryDirection(oppositeDirection[direction]);
    setCheckedBatRoom(false);
  }
};
          
  // First, define handleKeyPress OUTSIDE useEffect
const handleKeyPress = (e) => {
  if (e.code === 'Space' || Object.keys(keyToDirection).includes(e.key)) {
    e.preventDefault();
  }
  if (e.code === 'Space') {
    setIsArrowMode(prev => {
      playSound(arrowModeSound);
      return !prev;
    });
    return;
  }
  const direction = keyToDirection[e.key];
  if (!direction) return;
  if (isArrowMode) {
    const hitLocation = traceArrowPath(characterPos.x, characterPos.y, direction);
    setArrowDirection(direction);
    setShowArrow(true);
    playSound(arrowFlightSound);
    
    setTimeout(() => {
      setShowArrow(false);
      if (gameMap.gameMap[hitLocation.y][hitLocation.x] === TILE_TYPES.POINGLY) {
        playSound(victorySound);  
        setGameState('win');
        setWinCount(prev => prev + 1);
      } else {
        playSound(wumpusDeathSound);
        setGameState('poingly');
        setWumpusCount(prev => prev + 1);
      }
    }, 3000);
    return;
  }
  const currentTileType = gameMap.gameMap[characterPos.y][characterPos.x];
  const validMoves = getValidMoves(characterPos, currentTileType, entryDirection);
  if (!validMoves.includes(direction)) return;
  let newPos = { ...characterPos };
  switch(e.key) {
    case 'ArrowUp':
      newPos.y = (newPos.y - 1 + GRID_HEIGHT) % GRID_HEIGHT;
      break;
    case 'ArrowDown':
      newPos.y = (newPos.y + 1) % GRID_HEIGHT;
      break;
    case 'ArrowLeft':
      newPos.x = (newPos.x - 1 + GRID_WIDTH) % GRID_WIDTH;
      break;
    case 'ArrowRight':
      newPos.x = (newPos.x + 1) % GRID_WIDTH;
      break;
    default:
      return;
  }
  handleMovement(direction, newPos);
};

// Then define the touch handlers separately
const handleTouchStart = (e) => {
  setTouchStart({
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  });
  setTouchStartTime(Date.now());
};

const handleTouchEnd = (e) => {
  if (!touchStart || !touchStartTime) return;
  
  const touchEnd = {
    clientX: e.changedTouches[0].clientX,
    clientY: e.changedTouches[0].clientY
  };
  
  const touchDuration = Date.now() - touchStartTime;
  const diffX = touchEnd.clientX - touchStart.clientX;
  const diffY = touchEnd.clientY - touchStart.clientY;
  const distance = Math.sqrt(diffX * diffX + diffY * diffY);
  
  if (touchDuration < TAP_THRESHOLD && distance < SWIPE_THRESHOLD) {
    setIsArrowMode(prev => {
      playSound(arrowModeSound);
      return !prev;
    });
  } else {
    const swipeKey = getSwipeDirection(touchStart, touchEnd);
    if (swipeKey) {
      handleKeyPress({ key: swipeKey, preventDefault: () => {} });
    }
  }
  
  setTouchStart(null);
  setTouchStartTime(null);
};

const handleTouchMove = (e) => {
  e.preventDefault();
};

// Then a simple useEffect for keyboard events only
useEffect(() => {
  window.addEventListener('keydown', handleKeyPress);
  return () => {
    window.removeEventListener('keydown', handleKeyPress);
  };
}, [characterPos, entryDirection, gameMap, isArrowMode, checkedBatRoom, touchStart, touchStartTime]);
// Add this check here
if (!isGameStarted) {
  return (
    <StartScreen 
      onStart={handleGameStart} 
      sounds={soundEffects} 
      initialSoundEnabled={isSoundEnabled}
      initialHardMode={isHardMode}
      initialBlindfolded={isBlindfolded}
      initialExpressMode={isExpressMode}
    />
  );
}


// Victory screen


const EndGameButtons = ({ onPlayAgain, onReturnToStart, onViewMap, theme }) => (
  <div className="flex flex-col items-center space-y-3 w-full px-4 max-w-md">
    <button 
      onClick={onPlayAgain}
      onTouchEnd={(e) => { e.preventDefault(); onPlayAgain(); }}
      className={`w-full ${theme === 'light' ? 'bg-white text-black hover:bg-gray-200' : 'bg-black text-white hover:bg-gray-800'} px-6 py-4 rounded-lg text-xl`}
    >
      PLAY AGAIN
    </button>
    <button 
      onClick={onReturnToStart}
      onTouchEnd={(e) => { e.preventDefault(); onReturnToStart(); }}
      className={`w-full ${theme === 'light' ? 'bg-white text-black hover:bg-gray-200' : 'bg-black text-white hover:bg-gray-800'} px-6 py-4 rounded-lg text-xl`}
    >
      CHANGE OPTIONS
    </button>
    <button 
      onClick={() => window.open('https://open.spotify.com/artist/6z3lCFWZUtSMCtT3oFOzL2?si=8joPlZR6SdabLKL8KX5srA', '_blank')}
      onTouchEnd={(e) => { e.preventDefault(); window.open('https://open.spotify.com/artist/6z3lCFWZUtSMCtT3oFOzL2?si=8joPlZR6SdabLKL8KX5srA', '_blank'); }}
      className={`w-full ${theme === 'light' ? 'bg-white text-black hover:bg-gray-200' : 'bg-black text-white hover:bg-gray-800'} px-6 py-4 rounded-lg text-xl`}
    >
      POINGLY
    </button>
    <button 
      onClick={onViewMap}
      onTouchEnd={(e) => { e.preventDefault(); onViewMap(); }}
      className={`w-full ${theme === 'light' ? 'bg-white text-black hover:bg-gray-200' : 'bg-black text-white hover:bg-gray-800'} px-6 py-4 rounded-lg text-xl`}
    >
      VIEW MAP
    </button>
  </div>
);

// End game screens
if (showMap) {
  return <GameOverMap gameMap={gameMap} onClose={() => setShowMap(false)} />;
}
// Add a Stats component for reuse
const Stats = ({ winCount, pitCount, wumpusCount, theme = "light" }) => (
  <div className={`text-${theme === "light" ? "white" : "black"} text-lg md:text-xl mb-6 flex justify-center space-x-6`}>
    <div>Wins: {winCount}</div>
    <div>Pits: {pitCount}</div>
    <div>Wumpus: {wumpusCount}</div>
  </div>
);

// Update the end game screens to include stats
if (gameState === 'win') {
  return (
    <div className="fixed inset-0 bg-black">
      <div className="flex flex-col items-center justify-center min-h-screen p-4 max-h-screen">
        <h1 className="text-3xl md:text-6xl font-bold text-white mb-4 md:mb-8 text-center">
          YOU WIN!
        </h1>
        <Stats 
          winCount={winCount}
          pitCount={pitCount}
          wumpusCount={wumpusCount}
          theme="light"
        />
        <div className="w-full max-w-4xl">
          <EndGameButtons 
            onPlayAgain={handlePlayAgain}
            onReturnToStart={returnToStart}
            onViewMap={() => setShowMap(true)}
            theme="light"
          />
        </div>
      </div>
    </div>
  );
}

if (gameState === 'pit') {
  return (
    <div className={`fixed inset-0 bg-green-500 ${flashCount < 3 ? 'animate-flash' : ''}`}>
      <style>
        {`
          @keyframes flash {
            0%, 25%, 75% { background-color: black; }
            50%, 100% { background-color: rgb(34, 197, 94); }
          }
          .animate-flash {
            animation: flash 0.5s ease-in-out;
            animation-iteration-count: 2;
            animation-fill-mode: forwards;
          }
        `}
      </style>
      <div className="flex flex-col items-center justify-center min-h-screen p-4 max-h-screen">
        <h1 className="text-3xl md:text-6xl font-bold text-black mb-4 md:mb-8 text-center">
          YOU FELL IN A SLIME PIT!
        </h1>
        <Stats 
          winCount={winCount}
          pitCount={pitCount}
          wumpusCount={wumpusCount}
          theme="dark"
        />
        <div className="w-full max-w-4xl">
          <EndGameButtons 
            onPlayAgain={handlePlayAgain}
            onReturnToStart={returnToStart}
            onViewMap={() => setShowMap(true)}
            theme="dark"
          />
        </div>
      </div>
    </div>
  );
}

if (gameState === 'poingly') {
  return (
    <div className="fixed inset-0 bg-red-600">
      <div className="flex flex-col items-center justify-center min-h-screen p-4 max-h-screen">
        <div className="mb-4 md:mb-8">
          <div className="flex space-x-12 md:space-x-20">
            <div className="w-12 h-12 md:w-16 md:h-16 bg-white rounded-full flex items-center justify-center">
              <div className="w-6 h-6 md:w-8 md:h-8 bg-black rounded-full"></div>
            </div>
            <div className="w-12 h-12 md:w-16 md:h-16 bg-white rounded-full flex items-center justify-center">
              <div className="w-6 h-6 md:w-8 md:h-8 bg-black rounded-full"></div>
            </div>
          </div>
        </div>
        
        <h1 className="text-3xl md:text-6xl font-bold text-black mb-4 md:mb-8 text-center">
          YOU GOT EATEN BY THE WUMPUS!
        </h1>
        <Stats 
          winCount={winCount}
          pitCount={pitCount}
          wumpusCount={wumpusCount}
          theme="dark"
        />
        <div className="w-full max-w-4xl">
          <EndGameButtons 
            onPlayAgain={handlePlayAgain}
            onReturnToStart={returnToStart}
            onViewMap={() => setShowMap(true)}
            theme="dark"
          />
        </div>
      </div>
    </div>
  );
}

return (
    <div 
        className="fixed inset-0 bg-black"
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
        onTouchMove={handleTouchMove}
    >
      <div className="w-full h-full p-4 flex items-center justify-center">
        <svg
          viewBox={`0 0 ${GRID_WIDTH * TILE_SIZE} ${GRID_HEIGHT * TILE_SIZE}`}
          style={{
            width: '100%',
            maxWidth: '900px',
            height: '100%',
            maxHeight: '90vh'
          }}
          preserveAspectRatio="xMidYMid meet"
        >
            <rect 
  x="0" 
  y="0" 
  width={GRID_WIDTH * TILE_SIZE} 
  height={GRID_HEIGHT * TILE_SIZE} 
  fill="none" 
  stroke="rgba(255, 255, 255, 0.2)" 
  strokeWidth="1"
/>
          {/* First render fog tiles everywhere */}
{gameMap.gameMap.map((row, y) =>
  row.map((_, x) => {
    const isCurrentTile = characterPos.x === x && characterPos.y === y;
    if (isBlindfolded) {
      return !isCurrentTile && <FogTile key={`fog-${x}-${y}`} x={x} y={y} />;
    } else {
      return !visitedTiles[y][x].visited && 
             !(gameMap.gameMap[y][x] === TILE_TYPES.CURVE_1 && (visitedTiles[y][x].topRight || visitedTiles[y][x].bottomLeft)) &&
             !(gameMap.gameMap[y][x] === TILE_TYPES.CURVE_2 && (visitedTiles[y][x].topLeft || visitedTiles[y][x].bottomRight)) &&
             <FogTile key={`fog-${x}-${y}`} x={x} y={y} />;
    }
  })
)}

{/* Then render visible game tiles */}
{gameMap.gameMap.map((row, y) =>
  row.map((tileType, x) => {
    const key = `${x},${y}`;
    const isCurrentTile = characterPos.x === x && characterPos.y === y;
    const isCurve1 = tileType === TILE_TYPES.CURVE_1;
    const isCurve2 = tileType === TILE_TYPES.CURVE_2;
    
    // For curves in blindfold mode, determine which half should be visible based on entry direction
    const getCurveVisibility = () => {
      if (!isCurrentTile || !isBlindfolded) return visitedTiles[y][x];
      
      if (isCurve1) {
        return {
          ...visitedTiles[y][x],
          topRight: ['top', 'right'].includes(entryDirection),
          bottomLeft: ['bottom', 'left'].includes(entryDirection)
        };
      }
      if (isCurve2) {
        return {
          ...visitedTiles[y][x],
          topLeft: ['top', 'left'].includes(entryDirection),
          bottomRight: ['bottom', 'right'].includes(entryDirection)
        };
      }
      return visitedTiles[y][x];
    };
    
    const visibility = getCurveVisibility();
    
    // Determine if tile should be rendered
    const shouldRender = isBlindfolded ? 
      isCurrentTile : 
      visitedTiles[y][x].visited || 
      (isCurve1 && (visitedTiles[y][x].topRight || visitedTiles[y][x].bottomLeft)) ||
      (isCurve2 && (visitedTiles[y][x].topLeft || visitedTiles[y][x].bottomRight));

    if (!shouldRender) return null;

    return (
      <g key={key}>
        {tileType === TILE_TYPES.CIRCLE && <Circle x={x} y={y} />}
        {isCurve1 && 
          <PartialCurvePattern1 
            x={x} 
            y={y} 
            showTopRight={visibility.topRight}
            showBottomLeft={visibility.bottomLeft}
          />
        }
        {isCurve2 && 
          <PartialCurvePattern2 
            x={x} 
            y={y} 
            showTopLeft={visibility.topLeft}
            showBottomRight={visibility.bottomRight}
          />
        }
        {tileType === TILE_TYPES.PIT && <PitRoom x={x} y={y} />}
        {gameMap.warningRooms.pitWarnings.has(key) && <BreezeWarning x={x} y={y} />}
        {(gameMap.warningRooms.wumpusWarnings.has(key) ||
          gameMap.warningRooms.wumpusSecondaryWarnings.has(key)) && 
          <WumpusWarning x={x} y={y} />}
        {tileType === TILE_TYPES.POINGLY && <PoinglyRoom x={x} y={y} />}
        {tileType === TILE_TYPES.BAT && 
          <BatRoom 
            x={x} 
            y={y} 
            isAnimating={animatingBatRoom && animatingBatRoom.x === x && animatingBatRoom.y === y}
          />
        }
      </g>
    );
  })
)}
        <Character 
            x={characterPos.x} 
            y={characterPos.y} 
            tileType={gameMap.gameMap[characterPos.y][characterPos.x]}
            entryDirection={entryDirection}
            batAnimation={batAnimation}
            isArrowMode={isArrowMode}
          />
            {showArrow && (
    <Arrow
        viewportWidth={GRID_WIDTH * TILE_SIZE}
        viewportHeight={GRID_HEIGHT * TILE_SIZE}
        direction={arrowDirection}
        onComplete={() => setShowArrow(false)}
    />
)}
        </svg>
        
      </div>
    </div>
);
};

// Create root and render
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<GameBoard />);
    </script>
  </body>
</html>